{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS'); // @dynamic\n\nlet SmoothScrollManager = /*#__PURE__*/(() => {\n  class SmoothScrollManager {\n    constructor(_document, _platform, customDefaultOptions) {\n      this._document = _document;\n      this._platform = _platform; // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n      // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n      // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n      // it cancels the ongoing scroll and starts a new one\n\n      this._onGoingScrolls = new Map();\n      this._defaultOptions = Object.assign({\n        duration: 468,\n        easing: {\n          x1: 0.42,\n          y1: 0,\n          x2: 0.58,\n          y2: 1\n        }\n      }, customDefaultOptions);\n    }\n\n    get _w() {\n      return this._document.defaultView;\n    }\n    /**\r\n     * Timing method\r\n     */\n\n\n    get _now() {\n      return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now;\n    }\n    /**\r\n     * changes scroll position inside an element\r\n     */\n\n\n    _scrollElement(el, x, y) {\n      el.scrollLeft = x;\n      el.scrollTop = y;\n    }\n    /**\r\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n     */\n\n\n    _getElement(el, parent) {\n      if (typeof el === 'string') {\n        return (parent || this._document).querySelector(el);\n      }\n\n      return coerceElement(el);\n    }\n    /**\r\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n     */\n\n\n    _initSmoothScroll(el) {\n      if (this._onGoingScrolls.has(el)) {\n        this._onGoingScrolls.get(el).next();\n      }\n\n      return this._onGoingScrolls.set(el, new Subject()).get(el);\n    }\n    /**\r\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n     */\n\n\n    _isFinished(context, destroyed, resolve) {\n      if (context.currentX !== context.x || context.currentY !== context.y) {\n        return true;\n      }\n\n      destroyed.next();\n      resolve();\n      return false;\n    }\n    /**\r\n     * Terminates an ongoing smooth scroll\r\n     */\n\n\n    _interrupted(el, destroyed) {\n      return merge(fromEvent(el, 'wheel', {\n        passive: true,\n        capture: true\n      }), fromEvent(el, 'touchmove', {\n        passive: true,\n        capture: true\n      }), destroyed).pipe(take(1));\n    }\n    /**\r\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n     */\n\n\n    _destroy(el, destroyed) {\n      destroyed.complete();\n\n      this._onGoingScrolls.delete(el);\n    }\n    /**\r\n     * A function called recursively that, given a context, steps through scrolling\r\n     */\n\n\n    _step(context) {\n      return new Observable(subscriber => {\n        let elapsed = (this._now() - context.startTime) / context.duration; // avoid elapsed times higher than one\n\n        elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n        const value = context.easing(elapsed);\n        context.currentX = context.startX + (context.x - context.startX) * value;\n        context.currentY = context.startY + (context.y - context.startY) * value;\n\n        this._scrollElement(context.scrollable, context.currentX, context.currentY); // Proceed to the step\n\n\n        animationFrameScheduler.schedule(() => subscriber.next(context));\n      });\n    }\n\n    _applyScrollToOptions(el, options) {\n      if (!options.duration) {\n        this._scrollElement(el, options.left, options.top);\n\n        return Promise.resolve();\n      } // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n\n\n      const destroyed = this._initSmoothScroll(el);\n\n      const context = {\n        scrollable: el,\n        startTime: this._now(),\n        startX: el.scrollLeft,\n        startY: el.scrollTop,\n        x: options.left == null ? el.scrollLeft : ~~options.left,\n        y: options.top == null ? el.scrollTop : ~~options.top,\n        duration: options.duration,\n        easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n      };\n      return new Promise(resolve => {\n        // Scroll each step recursively\n        of(null).pipe(expand(() => this._step(context).pipe(takeWhile(currContext => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\n      });\n    }\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param scrollable element\r\n     * @param customOptions specified the offsets to scroll to.\r\n     */\n\n\n    scrollTo(scrollable, customOptions) {\n      if (isPlatformBrowser(this._platform)) {\n        const el = this._getElement(scrollable);\n\n        const isRtl = getComputedStyle(el).direction === 'rtl';\n        const rtlScrollAxisType = getRtlScrollAxisType();\n        const options = Object.assign(Object.assign(Object.assign({}, this._defaultOptions), customOptions), {\n          // Rewrite start & end offsets as right or left offsets.\n          left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n          right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n        }); // Rewrite the bottom offset as a top offset.\n\n        if (options.bottom != null) {\n          options.top = el.scrollHeight - el.clientHeight - options.bottom;\n        } // Rewrite the right offset as a left offset.\n\n\n        if (isRtl && rtlScrollAxisType !== 0\n        /* NORMAL */\n        ) {\n          if (options.left != null) {\n            options.right = el.scrollWidth - el.clientWidth - options.left;\n          }\n\n          if (rtlScrollAxisType === 2\n          /* INVERTED */\n          ) {\n            options.left = options.right;\n          } else if (rtlScrollAxisType === 1\n          /* NEGATED */\n          ) {\n            options.left = options.right ? -options.right : options.right;\n          }\n        } else {\n          if (options.right != null) {\n            options.left = el.scrollWidth - el.clientWidth - options.right;\n          }\n        }\n\n        return this._applyScrollToOptions(el, options);\n      }\n\n      return Promise.resolve();\n    }\n    /**\r\n     * Scroll to element by reference or selector\r\n     */\n\n\n    scrollToElement(scrollable, target, customOptions = {}) {\n      const scrollableEl = this._getElement(scrollable);\n\n      const targetEl = this._getElement(target, scrollableEl);\n\n      const options = Object.assign(Object.assign({}, customOptions), {\n        left: targetEl.offsetLeft + (customOptions.left || 0),\n        top: targetEl.offsetTop + (customOptions.top || 0)\n      });\n      return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n    }\n\n  }\n\n  SmoothScrollManager.ɵfac = function SmoothScrollManager_Factory(t) {\n    return new (t || SmoothScrollManager)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n  };\n\n  SmoothScrollManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SmoothScrollManager,\n    factory: SmoothScrollManager.ɵfac,\n    providedIn: 'root'\n  });\n  return SmoothScrollManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SmoothScroll = /*#__PURE__*/(() => {\n  class SmoothScroll {\n    constructor(element, smoothScroll) {\n      this.element = element;\n      this.smoothScroll = smoothScroll;\n    }\n\n    scrollTo(options) {\n      return this.smoothScroll.scrollTo(this.element, options);\n    }\n\n    scrollToElement(target, options) {\n      return this.smoothScroll.scrollToElement(this.element, target, options);\n    }\n\n  }\n\n  SmoothScroll.ɵfac = function SmoothScroll_Factory(t) {\n    return new (t || SmoothScroll)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SmoothScrollManager));\n  };\n\n  SmoothScroll.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SmoothScroll,\n    selectors: [[\"\", \"smoothScroll\", \"\"], [\"\", \"smooth-scroll\", \"\"]],\n    exportAs: [\"smoothScroll\"]\n  });\n  return SmoothScroll;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SmoothScrollModule = /*#__PURE__*/(() => {\n  class SmoothScrollModule {}\n\n  SmoothScrollModule.ɵfac = function SmoothScrollModule_Factory(t) {\n    return new (t || SmoothScrollModule)();\n  };\n\n  SmoothScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SmoothScrollModule\n  });\n  SmoothScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return SmoothScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule }; //# sourceMappingURL=ngx-scrollbar-smooth-scroll.mjs.map","map":null,"metadata":{},"sourceType":"module"}