{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Injectable, Optional, Inject, Output, Component, ChangeDetectionStrategy, ViewChild, Input, EventEmitter, RendererStyleFlags2, ElementRef, ContentChild, NgModule } from '@angular/core';\nimport * as i9 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i3 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport { PortalModule } from '@angular/cdk/portal';\nimport * as i2 from '@angular/cdk/platform';\nimport { getRtlScrollAxisType, PlatformModule } from '@angular/cdk/platform';\nimport * as i2$1 from 'ngx-scrollbar/smooth-scroll';\nimport { SmoothScrollModule } from 'ngx-scrollbar/smooth-scroll';\nimport { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Observable, fromEvent, merge, EMPTY, of, Subject, animationFrameScheduler, BehaviorSubject, Subscription } from 'rxjs';\nimport { tap, map, takeUntil, switchMap, pluck, distinctUntilChanged, mergeMap, debounceTime, pairwise, filter, auditTime } from 'rxjs/operators';\nconst _c0 = [\"scrollbarY\"];\nconst _c1 = [\"scrollbarX\"];\n\nfunction NgScrollbar_ng_container_5_scrollbar_x_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"scrollbar-x\", null, 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵattribute(\"scrollable\", ctx_r1.state.isHorizontallyScrollable)(\"fit\", ctx_r1.state.verticalUsed);\n  }\n}\n\nfunction NgScrollbar_ng_container_5_scrollbar_y_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"scrollbar-y\", null, 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵattribute(\"scrollable\", ctx_r2.state.isVerticallyScrollable)(\"fit\", ctx_r2.state.horizontalUsed);\n  }\n}\n\nfunction NgScrollbar_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, NgScrollbar_ng_container_5_scrollbar_x_1_Template, 2, 2, \"scrollbar-x\", 3);\n    i0.ɵɵtemplate(2, NgScrollbar_ng_container_5_scrollbar_y_2_Template, 2, 2, \"scrollbar-y\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.state.horizontalUsed);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.state.verticalUsed);\n  }\n}\n\nconst _c2 = [\"*\"];\n\nfunction preventSelection(doc) {\n  return tap(() => {\n    doc.onselectstart = () => false;\n  });\n}\n\nfunction enableSelection(doc) {\n  return tap(() => {\n    doc.onselectstart = null;\n  });\n}\n\nfunction stopPropagation() {\n  return tap(e => e.stopPropagation());\n}\n/**\r\n * Check if pointer is within scrollbar bounds\r\n */\n\n\nfunction isWithinBounds(e, rect) {\n  return e.clientX >= rect.left && e.clientX <= rect.left + rect.width && e.clientY >= rect.top && e.clientY <= rect.top + rect.height;\n}\n\nlet ScrollViewport = /*#__PURE__*/(() => {\n  class ScrollViewport {\n    constructor(viewPort) {\n      this.viewPort = viewPort;\n      this.nativeElement = viewPort.nativeElement;\n    } // Get viewport size, clientHeight or clientWidth\n\n\n    get clientHeight() {\n      return this.nativeElement.clientHeight;\n    }\n\n    get clientWidth() {\n      return this.nativeElement.clientWidth;\n    }\n\n    get scrollHeight() {\n      return this.nativeElement.scrollHeight;\n    }\n\n    get scrollWidth() {\n      return this.nativeElement.scrollWidth;\n    } // Get viewport scroll offset, scrollTop or scrollLeft\n\n\n    get scrollTop() {\n      return this.nativeElement.scrollTop;\n    }\n\n    get scrollLeft() {\n      return this.nativeElement.scrollLeft;\n    } // Get the available scrollable size\n\n\n    get scrollMaxX() {\n      return this.scrollWidth - this.clientWidth;\n    }\n\n    get scrollMaxY() {\n      return this.scrollHeight - this.clientHeight;\n    }\n\n    get contentHeight() {\n      var _a;\n\n      return ((_a = this.contentWrapperElement) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0;\n    }\n\n    get contentWidth() {\n      var _a;\n\n      return ((_a = this.contentWrapperElement) === null || _a === void 0 ? void 0 : _a.clientWidth) || 0;\n    }\n    /**\r\n     * Activate viewport pointer events such as 'hovered' and 'clicked' events\r\n     */\n\n\n    activatePointerEvents(propagate, destroyed) {\n      this.hovered = new Observable(subscriber => {\n        // Stream that emits when pointer is moved over the viewport (used to set the hovered state)\n        const mouseMoveStream = fromEvent(this.nativeElement, 'mousemove', {\n          passive: true\n        });\n        const mouseMove = propagate ? mouseMoveStream : mouseMoveStream.pipe(stopPropagation()); // Stream that emits when pointer leaves the viewport (used to remove the hovered state)\n\n        const mouseLeave = fromEvent(this.nativeElement, 'mouseleave', {\n          passive: true\n        }).pipe(map(() => false));\n        merge(mouseMove, mouseLeave).pipe(tap(e => subscriber.next(e)), takeUntil(destroyed)).subscribe();\n      });\n      this.clicked = new Observable(subscriber => {\n        const mouseDown = fromEvent(this.nativeElement, 'mousedown', {\n          passive: true\n        }).pipe(tap(e => subscriber.next(e)));\n        const mouseUp = fromEvent(this.nativeElement, 'mouseup', {\n          passive: true\n        }).pipe(tap(() => subscriber.next(false)));\n        mouseDown.pipe(switchMap(() => mouseUp), takeUntil(destroyed)).subscribe();\n      });\n    }\n    /**\r\n     * Set this directive as a non-functional wrapper, called when a custom viewport is used\r\n     */\n\n\n    setAsWrapper() {\n      // In this case the default viewport and the default content wrapper will act as a mask\n      this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';\n\n      if (this.nativeElement.firstElementChild) {\n        this.nativeElement.firstElementChild.className = 'ng-scroll-layer';\n      }\n    }\n    /**\r\n     * Set this directive as  the viewport, called when no custom viewport is used\r\n     */\n\n\n    setAsViewport(customClassName) {\n      this.nativeElement.className = `ng-native-scrollbar-hider ng-scroll-viewport ${customClassName}`; // Check if the custom viewport has only one child and set it as the content wrapper\n\n      if (this.nativeElement.firstElementChild) {\n        this.contentWrapperElement = this.nativeElement.firstElementChild;\n        this.contentWrapperElement.classList.add('ng-scroll-content');\n      }\n    }\n    /**\r\n     * Scroll viewport vertically\r\n     */\n\n\n    scrollYTo(value) {\n      this.nativeElement.scrollTop = value;\n    }\n    /**\r\n     * Scroll viewport horizontally\r\n     */\n\n\n    scrollXTo(value) {\n      this.nativeElement.scrollLeft = value;\n    }\n\n  }\n\n  ScrollViewport.ɵfac = function ScrollViewport_Factory(t) {\n    return new (t || ScrollViewport)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  ScrollViewport.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ScrollViewport,\n    selectors: [[\"\", \"scrollViewport\", \"\"]]\n  });\n  return ScrollViewport;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgScrollbarBase = /*#__PURE__*/(() => {\n  class NgScrollbarBase {}\n\n  NgScrollbarBase.ɵfac = function NgScrollbarBase_Factory(t) {\n    return new (t || NgScrollbarBase)();\n  };\n\n  NgScrollbarBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgScrollbarBase\n  });\n  return NgScrollbarBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');\nconst defaultOptions = {\n  viewClass: '',\n  trackClass: '',\n  thumbClass: '',\n  track: 'vertical',\n  appearance: 'compact',\n  visibility: 'native',\n  position: 'native',\n  pointerEventsMethod: 'viewport',\n  trackClickScrollDuration: 300,\n  minThumbSize: 20,\n  windowResizeDebounce: 0,\n  sensorDebounce: 0,\n  scrollAuditTime: 0,\n  viewportPropagateMouseMove: true,\n  autoHeightDisabled: true,\n  autoWidthDisabled: true,\n  sensorDisabled: false,\n  pointerEventsDisabled: false\n};\nlet ScrollbarManager = /*#__PURE__*/(() => {\n  class ScrollbarManager {\n    constructor(options) {\n      this.globalOptions = options ? Object.assign(Object.assign({}, defaultOptions), options) : defaultOptions;\n      this.rtlScrollAxisType = getRtlScrollAxisType();\n    }\n\n  }\n\n  ScrollbarManager.ɵfac = function ScrollbarManager_Factory(t) {\n    return new (t || ScrollbarManager)(i0.ɵɵinject(NG_SCROLLBAR_OPTIONS, 8));\n  };\n\n  ScrollbarManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScrollbarManager,\n    factory: ScrollbarManager.ɵfac,\n    providedIn: 'root'\n  });\n  return ScrollbarManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // @dynamic\n\n\nlet TrackAdapter = /*#__PURE__*/(() => {\n  class TrackAdapter {\n    constructor(cmp, trackElement, document) {\n      this.cmp = cmp;\n      this.trackElement = trackElement;\n      this.document = document;\n    } // Stream that emits when the track element is clicked\n\n\n    get clicked() {\n      const mouseDown = fromEvent(this.trackElement, 'mousedown', {\n        passive: true\n      }).pipe(stopPropagation(), preventSelection(this.document));\n      const mouseup = fromEvent(this.document, 'mouseup', {\n        passive: true\n      }).pipe(stopPropagation(), enableSelection(this.document), switchMap(() => EMPTY));\n      return merge(mouseDown, mouseup);\n    } // Get track client rect\n\n\n    get clientRect() {\n      return this.trackElement.getBoundingClientRect();\n    }\n    /**\r\n     * Stream that emits when scrollbar track is clicked\r\n     */\n\n\n    onTrackClicked(e, thumbSize, scrollSize) {\n      return of(e).pipe(pluck(this.pageProperty), // Calculate scrollTo position\n      map(pageOffset => {\n        const clickOffset = pageOffset - this.offset;\n        const offset = clickOffset - thumbSize / 2;\n        const ratio = offset / this.size;\n        return ratio * scrollSize;\n      }), // Smooth scroll to position\n      tap(value => {\n        this.cmp.scrollTo(Object.assign(Object.assign({}, this.mapToScrollToOption(value)), {\n          duration: coerceNumberProperty(this.cmp.trackClickScrollDuration)\n        }));\n      }));\n    }\n\n  }\n\n  TrackAdapter.ɵfac = function TrackAdapter_Factory(t) {\n    return new (t || TrackAdapter)(i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(HTMLElement), i0.ɵɵdirectiveInject(Document));\n  };\n\n  TrackAdapter.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TrackAdapter\n  });\n  return TrackAdapter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TrackXDirective = /*#__PURE__*/(() => {\n  class TrackXDirective extends TrackAdapter {\n    constructor(cmp, trackElement, document) {\n      super(cmp, trackElement.nativeElement, document);\n      this.cmp = cmp;\n      this.document = document;\n    }\n\n    get pageProperty() {\n      return 'pageX';\n    }\n\n    get offset() {\n      return this.clientRect.left;\n    }\n\n    get size() {\n      return this.trackElement.clientWidth;\n    }\n\n    mapToScrollToOption(value) {\n      return {\n        left: value\n      };\n    }\n\n  }\n\n  TrackXDirective.ɵfac = function TrackXDirective_Factory(t) {\n    return new (t || TrackXDirective)(i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  TrackXDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TrackXDirective,\n    selectors: [[\"\", \"scrollbarTrackX\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TrackXDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TrackYDirective = /*#__PURE__*/(() => {\n  class TrackYDirective extends TrackAdapter {\n    constructor(cmp, trackElement, document) {\n      super(cmp, trackElement.nativeElement, document);\n      this.cmp = cmp;\n      this.document = document;\n    }\n\n    get pageProperty() {\n      return 'pageY';\n    }\n\n    get offset() {\n      return this.clientRect.top;\n    }\n\n    get size() {\n      return this.trackElement.clientHeight;\n    }\n\n    mapToScrollToOption(value) {\n      return {\n        top: value\n      };\n    }\n\n  }\n\n  TrackYDirective.ɵfac = function TrackYDirective_Factory(t) {\n    return new (t || TrackYDirective)(i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  TrackYDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TrackYDirective,\n    selectors: [[\"\", \"scrollbarTrackY\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TrackYDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // @dynamic\n\n\nlet ThumbAdapter = /*#__PURE__*/(() => {\n  class ThumbAdapter {\n    constructor(cmp, track, thumbElement, document) {\n      this.cmp = cmp;\n      this.track = track;\n      this.thumbElement = thumbElement;\n      this.document = document; // Stream that emits dragging state\n\n      this._dragging = new Subject();\n      this.dragging = this._dragging.pipe(distinctUntilChanged());\n    }\n\n    get trackMax() {\n      return this.track.size - this.size;\n    } // Get thumb client rect\n\n\n    get clientRect() {\n      return this.thumbElement.getBoundingClientRect();\n    } // Stream that emits when scrollbar thumb is clicked\n\n\n    get clicked() {\n      return fromEvent(this.thumbElement, 'mousedown', {\n        passive: true\n      }).pipe(stopPropagation());\n    } // Calculate and update thumb position and size\n\n\n    update() {\n      const size = calculateThumbSize(this.track.size, this.viewportScrollSize, this.cmp.minThumbSize);\n      const position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);\n      animationFrameScheduler.schedule(() => this.updateStyles(this.handleDirection(position, this.trackMax), size));\n    }\n    /**\r\n     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged\r\n     * This function is called by thumb drag event using viewport or scrollbar pointer events\r\n     */\n\n\n    dragged(event) {\n      let trackMaxStart;\n      let scrollMaxStart;\n      const dragStart = of(event).pipe(preventSelection(this.document), tap(() => {\n        // Capture scrollMax and trackMax once\n        trackMaxStart = this.trackMax;\n        scrollMaxStart = this.viewportScrollMax;\n        this.setDragging(true);\n      }));\n      const dragging = fromEvent(this.document, 'mousemove', {\n        capture: true,\n        passive: true\n      }).pipe(stopPropagation());\n      const dragEnd = fromEvent(this.document, 'mouseup', {\n        capture: true\n      }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging(false)));\n      return dragStart.pipe(pluck(this.pageProperty), map(pageOffset => pageOffset - this.dragStartOffset), mergeMap(mouseDownOffset => dragging.pipe(pluck(this.clientProperty), // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).\n      map(mouseOffset => mouseOffset - this.track.offset), map(offset => scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart), map(position => this.handleDrag(position, scrollMaxStart)), tap(position => this.scrollTo(position)), takeUntil(dragEnd))));\n    }\n\n  }\n\n  ThumbAdapter.ɵfac = function ThumbAdapter_Factory(t) {\n    return new (t || ThumbAdapter)(i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(TrackAdapter), i0.ɵɵdirectiveInject(HTMLElement), i0.ɵɵdirectiveInject(Document));\n  };\n\n  ThumbAdapter.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThumbAdapter,\n    outputs: {\n      dragging: \"dragging\"\n    }\n  });\n  return ThumbAdapter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Calculate scrollbar thumb size\r\n */\n\n\nfunction calculateThumbSize(trackSize, contentSize, minThumbSize) {\n  const scrollbarRatio = trackSize / contentSize;\n  const thumbSize = scrollbarRatio * trackSize;\n  return Math.max(~~thumbSize, minThumbSize);\n}\n/**\r\n * Calculate scrollbar thumb position\r\n */\n\n\nfunction calculateThumbPosition(scrollPosition, scrollMax, trackMax) {\n  return scrollPosition * trackMax / scrollMax;\n}\n\nlet ThumbXDirective = /*#__PURE__*/(() => {\n  class ThumbXDirective extends ThumbAdapter {\n    constructor(cmp, track, element, document, dir) {\n      super(cmp, track, element.nativeElement, document);\n      this.cmp = cmp;\n      this.track = track;\n      this.element = element;\n      this.document = document;\n      this.dir = dir;\n    }\n\n    get clientProperty() {\n      return 'clientX';\n    }\n\n    get pageProperty() {\n      return 'pageX';\n    }\n\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollWidth;\n    }\n\n    get viewportScrollOffset() {\n      return this.cmp.viewport.scrollLeft;\n    }\n\n    get viewportScrollMax() {\n      return this.cmp.viewport.scrollMaxX;\n    }\n\n    get dragStartOffset() {\n      return this.clientRect.left + this.document.defaultView.pageXOffset || 0;\n    }\n\n    get size() {\n      return this.thumbElement.clientWidth;\n    }\n\n    updateStyles(position, size) {\n      this.thumbElement.style.width = `${size}px`;\n      this.thumbElement.style.transform = `translate3d(${position}px, 0, 0)`;\n    }\n\n    handleDrag(position, scrollMax) {\n      if (this.dir.value === 'rtl') {\n        if (this.cmp.manager.rtlScrollAxisType === 1\n        /* NEGATED */\n        ) {\n          return position - scrollMax;\n        }\n\n        if (this.cmp.manager.rtlScrollAxisType === 2\n        /* INVERTED */\n        ) {\n          return scrollMax - position;\n        } // Keeping this as a memo\n        // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {\n        //   return position;\n        // }\n\n      }\n\n      return position;\n    }\n\n    handleDirection(position, trackMax) {\n      if (this.dir.value === 'rtl') {\n        if (this.cmp.manager.rtlScrollAxisType === 2\n        /* INVERTED */\n        ) {\n          return -position;\n        }\n\n        if (this.cmp.manager.rtlScrollAxisType === 0\n        /* NORMAL */\n        ) {\n          return position - trackMax;\n        } // Keeping this as a memo\n        // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {\n        //   return position;\n        // }\n\n      }\n\n      return position;\n    }\n\n    setDragging(value) {\n      this.cmp.setDragging({\n        horizontalDragging: value\n      });\n    }\n\n    scrollTo(position) {\n      this.cmp.viewport.scrollXTo(position);\n    }\n\n  }\n\n  ThumbXDirective.ɵfac = function ThumbXDirective_Factory(t) {\n    return new (t || ThumbXDirective)(i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(TrackXDirective), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i3.Directionality));\n  };\n\n  ThumbXDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThumbXDirective,\n    selectors: [[\"\", \"scrollbarThumbX\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThumbXDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ThumbYDirective = /*#__PURE__*/(() => {\n  class ThumbYDirective extends ThumbAdapter {\n    constructor(cmp, track, element, document) {\n      super(cmp, track, element.nativeElement, document);\n      this.cmp = cmp;\n      this.track = track;\n      this.element = element;\n      this.document = document;\n    }\n\n    get pageProperty() {\n      return 'pageY';\n    }\n\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollHeight;\n    }\n\n    get viewportScrollOffset() {\n      return this.cmp.viewport.scrollTop;\n    }\n\n    get viewportScrollMax() {\n      return this.cmp.viewport.scrollMaxY;\n    }\n\n    get clientProperty() {\n      return 'clientY';\n    }\n\n    get dragStartOffset() {\n      return this.clientRect.top + this.document.defaultView.pageYOffset || 0;\n    }\n\n    get size() {\n      return this.thumbElement.clientHeight;\n    }\n\n    updateStyles(position, size) {\n      this.thumbElement.style.height = `${size}px`;\n      this.thumbElement.style.transform = `translate3d(0px, ${position}px, 0)`;\n    }\n\n    handleDrag(position) {\n      return position;\n    }\n\n    handleDirection(position) {\n      return position;\n    }\n\n    setDragging(value) {\n      this.cmp.setDragging({\n        verticalDragging: value\n      });\n    }\n\n    scrollTo(position) {\n      this.cmp.viewport.scrollYTo(position);\n    }\n\n  }\n\n  ThumbYDirective.ɵfac = function ThumbYDirective_Factory(t) {\n    return new (t || ThumbYDirective)(i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(TrackYDirective), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  ThumbYDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ThumbYDirective,\n    selectors: [[\"\", \"scrollbarThumbY\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ThumbYDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // @dynamic\n\n\nlet Scrollbar = /*#__PURE__*/(() => {\n  class Scrollbar {\n    constructor(el, cmp, platform, document, zone) {\n      this.el = el;\n      this.cmp = cmp;\n      this.platform = platform;\n      this.document = document;\n      this.zone = zone; // Stream that emits to unsubscribe from all streams\n\n      this.destroyed = new Subject();\n    }\n    /**\r\n     * Activate scrollbar pointer events\r\n     */\n\n\n    activatePointerEvents() {\n      // Stream that emits when scrollbar thumb is dragged\n      let thumbDragEvent; // Stream that emits when scrollbar track is clicked\n\n      let trackClickEvent; // Stream that emits when scrollbar track is hovered\n\n      let trackHoveredEvent; // Set the method used for the pointer events option\n\n      if (this.cmp.pointerEventsMethod === 'viewport') {\n        // Pointer events using the viewport\n        this.viewportTrackClicked = new Subject();\n        this.viewportThumbClicked = new Subject(); // Activate the pointer events of the viewport directive\n\n        this.cmp.viewport.activatePointerEvents(this.cmp.viewportPropagateMouseMove, this.destroyed); // Set streams\n\n        thumbDragEvent = this.viewportThumbClicked;\n        trackClickEvent = this.viewportTrackClicked;\n        trackHoveredEvent = this.cmp.viewport.hovered.pipe( // Check if track is hovered\n        map(e => e ? isWithinBounds(e, this.el.getBoundingClientRect()) : false), distinctUntilChanged(), // Enable / disable text selection\n        tap(hovered => this.document.onselectstart = hovered ? () => false : null));\n        this.cmp.viewport.clicked.pipe(tap(e => {\n          if (e) {\n            if (isWithinBounds(e, this.thumb.clientRect)) {\n              this.viewportThumbClicked.next(e);\n            } else if (isWithinBounds(e, this.track.clientRect)) {\n              this.cmp.setClicked(true);\n              this.viewportTrackClicked.next(e);\n            }\n          } else {\n            this.cmp.setClicked(false);\n          }\n        }), takeUntil(this.destroyed)).subscribe();\n      } else {\n        // Pointer events method is using 'scrollbar'\n        thumbDragEvent = this.thumb.clicked;\n        trackClickEvent = this.track.clicked;\n        trackHoveredEvent = this.hovered;\n      }\n\n      return merge( // Activate scrollbar hovered event\n      trackHoveredEvent.pipe(tap(e => this.setHovered(e))), // Activate scrollbar thumb drag event\n      thumbDragEvent.pipe(switchMap(e => this.thumb.dragged(e))), // Activate scrollbar track click event\n      trackClickEvent.pipe(switchMap(e => this.track.onTrackClicked(e, this.thumb.size, this.viewportScrollSize))));\n    } // Stream that emits when the track element is hovered\n\n\n    get hovered() {\n      const mouseEnter = fromEvent(this.el, 'mouseenter', {\n        passive: true\n      }).pipe(stopPropagation(), map(() => true));\n      const mouseLeave = fromEvent(this.el, 'mouseleave', {\n        passive: true\n      }).pipe(stopPropagation(), map(() => false));\n      return merge(mouseEnter, mouseLeave);\n    }\n\n    ngOnInit() {\n      this.zone.runOutsideAngular(() => {\n        // Activate pointer events on Desktop only\n        if (!(this.platform.IOS || this.platform.ANDROID) && !this.cmp.pointerEventsDisabled) {\n          this.activatePointerEvents().pipe(takeUntil(this.destroyed)).subscribe();\n        } // Update scrollbar thumb when viewport is scrolled and when scrollbar component is updated\n\n\n        merge(this.cmp.scrolled, this.cmp.updated).pipe(tap(() => {\n          var _a;\n\n          return (_a = this.thumb) === null || _a === void 0 ? void 0 : _a.update();\n        }), takeUntil(this.destroyed)).subscribe();\n      });\n    }\n\n    ngOnDestroy() {\n      this.destroyed.next();\n      this.destroyed.complete(); // Clean up viewport streams if used\n\n      if (this.viewportThumbClicked && this.viewportTrackClicked) {\n        this.viewportTrackClicked.complete();\n        this.viewportThumbClicked.complete();\n      }\n    }\n\n  }\n\n  Scrollbar.ɵfac = function Scrollbar_Factory(t) {\n    return new (t || Scrollbar)(i0.ɵɵdirectiveInject(HTMLElement), i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(Document), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  Scrollbar.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Scrollbar\n  });\n  return Scrollbar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ScrollbarY = /*#__PURE__*/(() => {\n  class ScrollbarY extends Scrollbar {\n    constructor(el, cmp, platform, document, zone) {\n      super(el.nativeElement, cmp, platform, document, zone);\n      this.cmp = cmp;\n      this.platform = platform;\n      this.document = document;\n      this.zone = zone;\n    }\n\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollHeight;\n    }\n\n    setHovered(value) {\n      this.cmp.setHovered({\n        verticalHovered: value\n      });\n    }\n\n  }\n\n  ScrollbarY.ɵfac = function ScrollbarY_Factory(t) {\n    return new (t || ScrollbarY)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ScrollbarY.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ScrollbarY,\n    selectors: [[\"scrollbar-y\"]],\n    viewQuery: function ScrollbarY_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TrackYDirective, 7);\n        i0.ɵɵviewQuery(ThumbYDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ScrollbarY_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"scrollbar-control\", true);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 6,\n    consts: [[\"scrollbarTrackY\", \"\"], [\"scrollbarThumbY\", \"\"]],\n    template: function ScrollbarY_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-track \", ctx.cmp.trackClass, \"\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-thumb \", ctx.cmp.thumbClass, \"\");\n      }\n    },\n    directives: [TrackYDirective, ThumbYDirective],\n    styles: [\".ng-scrollbar-wrapper>scrollbar-y.scrollbar-control{width:var(--vertical-scrollbar-total-size)}  .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}  .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}  .ng-scrollbar-wrapper[verticalHovered=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[verticalDragging=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[deactivated=false]>scrollbar-y.scrollbar-control{top:0;bottom:0}  .ng-scrollbar-wrapper[deactivated=false][dir=ltr]>scrollbar-y.scrollbar-control{right:0;left:unset}  .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertY]>scrollbar-y.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertAll]>scrollbar-y.scrollbar-control{left:0;right:unset}  .ng-scrollbar-wrapper[deactivated=false][dir=rtl]>scrollbar-y.scrollbar-control{left:0;right:unset}  .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertY]>scrollbar-y.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertAll]>scrollbar-y.scrollbar-control{left:unset;right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all]>scrollbar-y.scrollbar-control[fit=true]{bottom:var(--scrollbar-total-size);top:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertX]>scrollbar-y.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertAll]>scrollbar-y.scrollbar-control[fit=true]{top:var(--scrollbar-total-size);bottom:0}\"],\n    changeDetection: 0\n  });\n  return ScrollbarY;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ScrollbarX = /*#__PURE__*/(() => {\n  class ScrollbarX extends Scrollbar {\n    constructor(el, cmp, platform, document, zone) {\n      super(el.nativeElement, cmp, platform, document, zone);\n      this.cmp = cmp;\n      this.platform = platform;\n      this.document = document;\n      this.zone = zone;\n    }\n\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollWidth;\n    }\n\n    setHovered(value) {\n      this.cmp.setHovered({\n        horizontalHovered: value\n      });\n    }\n\n  }\n\n  ScrollbarX.ɵfac = function ScrollbarX_Factory(t) {\n    return new (t || ScrollbarX)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgScrollbarBase), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ScrollbarX.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ScrollbarX,\n    selectors: [[\"scrollbar-x\"]],\n    viewQuery: function ScrollbarX_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TrackXDirective, 7);\n        i0.ɵɵviewQuery(ThumbXDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ScrollbarX_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"scrollbar-control\", true);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 6,\n    consts: [[\"scrollbarTrackX\", \"\"], [\"scrollbarThumbX\", \"\"]],\n    template: function ScrollbarX_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-track \", ctx.cmp.trackClass, \"\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-thumb \", ctx.cmp.thumbClass, \"\");\n      }\n    },\n    directives: [TrackXDirective, ThumbXDirective],\n    styles: [\".ng-scrollbar-wrapper>scrollbar-x.scrollbar-control{height:var(--horizontal-scrollbar-total-size)}  .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}  .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}  .ng-scrollbar-wrapper[horizontalHovered=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[horizontalDragging=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[position=invertX]>scrollbar-x.scrollbar-control,   .ng-scrollbar-wrapper[position=invertAll]>scrollbar-x.scrollbar-control{top:0;bottom:unset}  .ng-scrollbar-wrapper[deactivated=false]>scrollbar-x.scrollbar-control{left:0;right:0;bottom:0;top:unset}  .ng-scrollbar-wrapper[deactivated=false][position=invertX]>scrollbar-x.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][position=invertAll]>scrollbar-x.scrollbar-control{top:0;bottom:unset}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertY]>scrollbar-x.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertAll]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertY]>scrollbar-x.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertAll]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}\"],\n    changeDetection: 0\n  });\n  return ScrollbarX;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgAttr = /*#__PURE__*/(() => {\n  class NgAttr {\n    constructor(el) {\n      this.el = el;\n    }\n\n    set ngAttr(attrs) {\n      for (const [key, value] of Object.entries(attrs)) {\n        this.el.nativeElement.setAttribute(key, value);\n      }\n    }\n\n  }\n\n  NgAttr.ɵfac = function NgAttr_Factory(t) {\n    return new (t || NgAttr)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  NgAttr.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgAttr,\n    selectors: [[\"\", \"ngAttr\", \"\"]],\n    inputs: {\n      ngAttr: \"ngAttr\"\n    }\n  });\n  return NgAttr;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ResizeSensor = /*#__PURE__*/(() => {\n  class ResizeSensor {\n    constructor(zone, platform, scrollbar) {\n      this.zone = zone;\n      this.platform = platform;\n      this.scrollbar = scrollbar;\n      this._disabled = false;\n      this._currentSubscription = null;\n      this.event = new EventEmitter();\n\n      if (!scrollbar) {\n        throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');\n      }\n    }\n    /** Debounce interval for emitting the changes. */\n\n\n    get debounce() {\n      return this._debounce;\n    }\n\n    set debounce(value) {\n      this._debounce = coerceNumberProperty(value);\n\n      this._subscribe();\n    }\n    /** Whether ResizeObserver is disabled. */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n      this._disabled ? this._unsubscribe() : this._subscribe();\n    }\n\n    ngAfterContentInit() {\n      if (!this._currentSubscription && !this._disabled) {\n        this._subscribe();\n      }\n    }\n\n    ngOnDestroy() {\n      this._unsubscribe();\n    }\n\n    _subscribe() {\n      this._unsubscribe();\n\n      if (this.platform.isBrowser) {\n        const stream = new Observable(observer => {\n          this._resizeObserver = new ResizeObserver(e => observer.next(e));\n\n          this._resizeObserver.observe(this.scrollbar.viewport.nativeElement);\n\n          if (this.scrollbar.viewport.contentWrapperElement) {\n            this._resizeObserver.observe(this.scrollbar.viewport.contentWrapperElement);\n          }\n        });\n        this.zone.runOutsideAngular(() => {\n          this._currentSubscription = (this._debounce ? stream.pipe(debounceTime(this._debounce)) : stream).subscribe(this.event);\n        });\n      }\n    }\n\n    _unsubscribe() {\n      var _a, _b;\n\n      (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n      (_b = this._currentSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();\n    }\n\n  }\n\n  ResizeSensor.ɵfac = function ResizeSensor_Factory(t) {\n    return new (t || ResizeSensor)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(NgScrollbarBase));\n  };\n\n  ResizeSensor.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ResizeSensor,\n    selectors: [[\"\", \"resizeSensor\", \"\"]],\n    inputs: {\n      debounce: [\"sensorDebounce\", \"debounce\"],\n      disabled: [\"sensorDisabled\", \"disabled\"]\n    },\n    outputs: {\n      event: \"resizeSensor\"\n    }\n  });\n  return ResizeSensor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NativeScrollbarSizeFactory = /*#__PURE__*/(() => {\n  class NativeScrollbarSizeFactory {\n    constructor(document, manager, platform) {\n      this.document = document;\n      this.manager = manager;\n      this.platform = platform;\n      this._scrollbarSize = new BehaviorSubject(this.getNativeScrollbarSize());\n      this.scrollbarSize = this._scrollbarSize.asObservable(); // Calculate native scrollbar size on window resize event, because the size changes if use zoomed in/out\n\n      if (platform.isBrowser) {\n        fromEvent(this.document.defaultView, 'resize', {\n          passive: true\n        }).pipe(debounceTime(this.manager.globalOptions.windowResizeDebounce), map(() => this.getNativeScrollbarSize()), distinctUntilChanged(), tap(size => this._scrollbarSize.next(size))).subscribe();\n      }\n    }\n    /**\r\n     * Get native scrollbar size\r\n     */\n\n\n    getNativeScrollbarSize() {\n      // Avoid executing browser code in server side rendering\n      if (!this.platform.isBrowser) {\n        return 0;\n      } // Hide iOS browsers native scrollbar\n\n\n      if (this.platform.IOS) {\n        return 6;\n      }\n\n      const box = this.document.createElement('div');\n      box.className = 'ng-scrollbar-measure';\n      box.style.left = '0px';\n      box.style.overflow = 'scroll';\n      box.style.position = 'fixed';\n      box.style.top = '-9999px';\n      this.document.body.appendChild(box);\n      const size = box.getBoundingClientRect().right;\n      this.document.body.removeChild(box);\n      return size;\n    }\n\n  }\n\n  NativeScrollbarSizeFactory.ɵfac = function NativeScrollbarSizeFactory_Factory(t) {\n    return new (t || NativeScrollbarSizeFactory)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(ScrollbarManager), i0.ɵɵinject(i2.Platform));\n  };\n\n  NativeScrollbarSizeFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NativeScrollbarSizeFactory,\n    factory: NativeScrollbarSizeFactory.ɵfac,\n    providedIn: 'root'\n  });\n  return NativeScrollbarSizeFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet HideNativeScrollbar = /*#__PURE__*/(() => {\n  class HideNativeScrollbar {\n    constructor(el, renderer, hideNativeScrollbar) {\n      this.renderer = renderer;\n      this.hideNativeScrollbar = hideNativeScrollbar;\n      this._subscriber = Subscription.EMPTY;\n      this._subscriber = hideNativeScrollbar.scrollbarSize.subscribe(size => {\n        this.renderer.setStyle(el.nativeElement, '--native-scrollbar-size', `-${size}px`, RendererStyleFlags2.DashCase);\n      });\n    }\n\n    ngOnDestroy() {\n      this._subscriber.unsubscribe();\n    }\n\n  }\n\n  HideNativeScrollbar.ɵfac = function HideNativeScrollbar_Factory(t) {\n    return new (t || HideNativeScrollbar)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(NativeScrollbarSizeFactory));\n  };\n\n  HideNativeScrollbar.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HideNativeScrollbar,\n    selectors: [[\"\", \"hideNativeScrollbar\", \"\"]]\n  });\n  return HideNativeScrollbar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgScrollbar = /*#__PURE__*/(() => {\n  class NgScrollbar {\n    constructor(el, zone, changeDetectorRef, dir, smoothScroll, manager) {\n      this.el = el;\n      this.zone = zone;\n      this.changeDetectorRef = changeDetectorRef;\n      this.dir = dir;\n      this.smoothScroll = smoothScroll;\n      this.manager = manager;\n      this._disabled = false;\n      this._sensorDisabled = this.manager.globalOptions.sensorDisabled;\n      this._pointerEventsDisabled = this.manager.globalOptions.pointerEventsDisabled;\n      this._autoHeightDisabled = this.manager.globalOptions.autoHeightDisabled;\n      this._autoWidthDisabled = this.manager.globalOptions.autoWidthDisabled;\n      this._viewportPropagateMouseMove = this.manager.globalOptions.viewportPropagateMouseMove;\n      /** A class forwarded to scrollable viewport element */\n\n      this.viewClass = this.manager.globalOptions.viewClass;\n      /** A class forwarded to the scrollbar track element */\n\n      this.trackClass = this.manager.globalOptions.trackClass;\n      /** A class forwarded to the scrollbar thumb element */\n\n      this.thumbClass = this.manager.globalOptions.thumbClass;\n      /** Minimum scrollbar thumb size */\n\n      this.minThumbSize = this.manager.globalOptions.minThumbSize;\n      /** The duration which the scrolling takes to reach its target when scrollbar rail is clicked */\n\n      this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;\n      /**\r\n       * Sets the pointer events method\r\n       * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)\r\n       * Use scrollbar pointer events to handle dragging and track click\r\n       */\n\n      this.pointerEventsMethod = this.manager.globalOptions.pointerEventsMethod;\n      /**\r\n       * Sets the supported scroll track of the viewport, there are 3 options:\r\n       *\r\n       * - `vertical` Use both vertical and horizontal scrollbar\r\n       * - `horizontal` Use both vertical and horizontal scrollbar\r\n       * - `all` Use both vertical and horizontal scrollbar\r\n       */\n\n      this.track = this.manager.globalOptions.track;\n      /**\r\n       * When to show the scrollbar, and there are 3 options:\r\n       *\r\n       * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar\r\n       * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering\r\n       * - `always` Scrollbars are always shown even if the viewport is not scrollable\r\n       */\n\n      this.visibility = this.manager.globalOptions.visibility;\n      /**\r\n       *  Sets the appearance of the scrollbar, there are 2 options:\r\n       *\r\n       * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.\r\n       * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.\r\n       */\n\n      this.appearance = this.manager.globalOptions.appearance;\n      /**\r\n       * Sets the position of each scrollbar, there are 4 options:\r\n       *\r\n       * - `native` (Default) Use the default position like in native scrollbar.\r\n       * - `invertY` Inverts vertical scrollbar position\r\n       * - `invertX` Inverts Horizontal scrollbar position\r\n       * - `invertAll` Inverts both scrollbar positions\r\n       */\n\n      this.position = this.manager.globalOptions.position;\n      /** Debounce interval for detecting changes via ResizeObserver */\n\n      this.sensorDebounce = this.manager.globalOptions.sensorDebounce;\n      /** Scroll Audit Time */\n\n      this.scrollAuditTime = this.manager.globalOptions.scrollAuditTime;\n      /** Steam that emits when scrollbar is updated */\n\n      this.updated = new EventEmitter();\n      /** Set of attributes added on the scrollbar wrapper */\n\n      this.state = {};\n      /** Stream that destroys components' observables */\n\n      this.destroyed = new Subject();\n    }\n    /** Disable custom scrollbar and switch back to native scrollbar */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(disabled) {\n      this._disabled = coerceBooleanProperty(disabled);\n    }\n    /** Whether ResizeObserver is disabled */\n\n\n    get sensorDisabled() {\n      return this._sensorDisabled;\n    }\n\n    set sensorDisabled(disabled) {\n      this._sensorDisabled = coerceBooleanProperty(disabled);\n    }\n    /** A flag used to enable/disable the scrollbar thumb dragged event */\n\n\n    get pointerEventsDisabled() {\n      return this._pointerEventsDisabled;\n    }\n\n    set pointerEventsDisabled(disabled) {\n      this._pointerEventsDisabled = coerceBooleanProperty(disabled);\n    }\n    /** Enable viewport mousemove event propagation (only when pointerEventsMethod=\"viewport\") */\n\n\n    get viewportPropagateMouseMove() {\n      return this._viewportPropagateMouseMove;\n    }\n\n    set viewportPropagateMouseMove(disabled) {\n      this._viewportPropagateMouseMove = coerceBooleanProperty(disabled);\n    }\n    /** Disable auto-height */\n\n\n    get autoHeightDisabled() {\n      return this._autoHeightDisabled;\n    }\n\n    set autoHeightDisabled(disabled) {\n      this._autoHeightDisabled = coerceBooleanProperty(disabled);\n    }\n    /** Disable auto-width */\n\n\n    get autoWidthDisabled() {\n      return this._autoWidthDisabled;\n    }\n\n    set autoWidthDisabled(disabled) {\n      this._autoWidthDisabled = coerceBooleanProperty(disabled);\n    }\n\n    get nativeElement() {\n      return this.el.nativeElement;\n    }\n    /**\r\n     * Update local state with each change detection\r\n     */\n\n\n    updateState() {\n      let verticalUsed = false;\n      let horizontalUsed = false;\n      let isVerticallyScrollable = false;\n      let isHorizontallyScrollable = false; // Check if vertical scrollbar should be displayed\n\n      if (this.track === 'all' || this.track === 'vertical') {\n        isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;\n        verticalUsed = this.visibility === 'always' || isVerticallyScrollable;\n      } // Check if horizontal scrollbar should be displayed\n\n\n      if (this.track === 'all' || this.track === 'horizontal') {\n        isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;\n        horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;\n      } // Update inner wrapper attributes\n\n\n      this.setState({\n        position: this.position,\n        track: this.track,\n        appearance: this.appearance,\n        visibility: this.visibility,\n        deactivated: this.disabled,\n        dir: this.dir.value,\n        pointerEventsMethod: this.pointerEventsMethod,\n        verticalUsed,\n        horizontalUsed,\n        isVerticallyScrollable,\n        isHorizontallyScrollable\n      });\n    }\n\n    setState(state) {\n      this.state = Object.assign(Object.assign({}, this.state), state);\n      this.changeDetectorRef.detectChanges();\n    }\n\n    getScrolledByDirection(property) {\n      let event;\n      return this.scrolled.pipe(tap(e => event = e), pluck('target', property), pairwise(), filter(([prev, curr]) => prev !== curr), map(() => event));\n    }\n    /**\r\n     * Set hovered state if a scrollbar is being hovered\r\n     */\n\n\n    setHovered(hovered) {\n      this.zone.run(() => this.setState(Object.assign({}, hovered)));\n    }\n    /**\r\n     * Set dragging state if a scrollbar is being dragged\r\n     */\n\n\n    setDragging(dragging) {\n      this.zone.run(() => this.setState(Object.assign({}, dragging)));\n    }\n    /**\r\n     * Set clicked state if a scrollbar track is being click\r\n     */\n\n\n    setClicked(scrollbarClicked) {\n      this.zone.run(() => this.setState({\n        scrollbarClicked\n      }));\n    }\n\n    ngOnInit() {\n      // Set the viewport based on user choice\n      this.zone.runOutsideAngular(() => {\n        if (this.customViewPort) {\n          this.viewport = this.customViewPort;\n          this.defaultViewPort.setAsWrapper();\n        } else {\n          this.viewport = this.defaultViewPort;\n        } // Activate the selected viewport\n\n\n        this.viewport.setAsViewport(this.viewClass);\n        let scrollStream = fromEvent(this.viewport.nativeElement, 'scroll', {\n          passive: true\n        }); // Throttle scroll event if 'scrollAuditTime' is set\n\n        scrollStream = this.scrollAuditTime ? scrollStream.pipe(auditTime(this.scrollAuditTime)) : scrollStream; // Initialize scroll streams\n\n        this.scrolled = scrollStream.pipe(takeUntil(this.destroyed));\n        this.verticalScrolled = this.getScrolledByDirection('scrollTop');\n        this.horizontalScrolled = this.getScrolledByDirection('scrollLeft');\n      });\n    }\n\n    ngOnChanges(changes) {\n      // Update only when the viewport is initialized\n      if (this.viewport) {\n        this.update();\n      }\n    }\n\n    ngAfterViewInit() {\n      // Initial update\n      this.update(); // Update on dir changes\n\n      this.dir.change.pipe(tap(() => this.update()), takeUntil(this.destroyed)).subscribe();\n    }\n\n    ngOnDestroy() {\n      this.destroyed.next();\n      this.destroyed.complete();\n    }\n    /**\r\n     * Update local state and the internal scrollbar controls\r\n     */\n\n\n    update() {\n      if (!this.autoHeightDisabled) {\n        this.updateHeight();\n      }\n\n      if (!this.autoWidthDisabled) {\n        this.updateWidth();\n      } // Re-evaluate the state after setting height or width\n\n\n      this.updateState();\n      this.updated.next();\n    }\n    /**\r\n     * Smooth scroll functions\r\n     */\n\n\n    scrollTo(options) {\n      return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);\n    }\n    /**\r\n     * Scroll to element by reference or selector\r\n     */\n\n\n    scrollToElement(target, options) {\n      return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);\n    }\n\n    updateHeight() {\n      // Auto-height: Set component height to content height\n      if (this.appearance === 'standard' && this.scrollbarX) {\n        // if scrollbar-x is displayed in standard mode\n        this.nativeElement.style.height = `${this.viewport.contentHeight + this.scrollbarX.nativeElement.clientHeight}px`;\n      } else {\n        this.nativeElement.style.height = `${this.viewport.contentHeight}px`;\n      }\n    }\n\n    updateWidth() {\n      // Auto-width: Set component minWidth to content width\n      if (this.appearance === 'standard' && this.scrollbarY) {\n        // if scrollbar-y is displayed in standard mode\n        this.nativeElement.style.width = `${this.viewport.contentWidth + this.scrollbarY.nativeElement.clientWidth}px`;\n      } else {\n        this.nativeElement.style.width = `${this.viewport.contentWidth}px`;\n      }\n    }\n\n  }\n\n  NgScrollbar.ɵfac = function NgScrollbar_Factory(t) {\n    return new (t || NgScrollbar)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.Directionality), i0.ɵɵdirectiveInject(i2$1.SmoothScrollManager), i0.ɵɵdirectiveInject(ScrollbarManager));\n  };\n\n  NgScrollbar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgScrollbar,\n    selectors: [[\"ng-scrollbar\"]],\n    contentQueries: function NgScrollbar_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ScrollViewport, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customViewPort = _t.first);\n      }\n    },\n    viewQuery: function NgScrollbar_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5, ElementRef);\n        i0.ɵɵviewQuery(_c1, 5, ElementRef);\n        i0.ɵɵviewQuery(ScrollViewport, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollbarY = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollbarX = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultViewPort = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function NgScrollbar_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ng-scrollbar\", true);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      sensorDisabled: \"sensorDisabled\",\n      pointerEventsDisabled: \"pointerEventsDisabled\",\n      viewportPropagateMouseMove: \"viewportPropagateMouseMove\",\n      autoHeightDisabled: \"autoHeightDisabled\",\n      autoWidthDisabled: \"autoWidthDisabled\",\n      viewClass: \"viewClass\",\n      trackClass: \"trackClass\",\n      thumbClass: \"thumbClass\",\n      minThumbSize: \"minThumbSize\",\n      trackClickScrollDuration: \"trackClickScrollDuration\",\n      pointerEventsMethod: \"pointerEventsMethod\",\n      track: \"track\",\n      visibility: \"visibility\",\n      appearance: \"appearance\",\n      position: \"position\",\n      sensorDebounce: \"sensorDebounce\",\n      scrollAuditTime: \"scrollAuditTime\"\n    },\n    outputs: {\n      updated: \"updated\"\n    },\n    exportAs: [\"ngScrollbar\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NgScrollbarBase,\n      useExisting: NgScrollbar\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c2,\n    decls: 6,\n    vars: 4,\n    consts: [[1, \"ng-scrollbar-wrapper\", 3, \"ngAttr\"], [1, \"ng-scroll-viewport-wrapper\", 3, \"sensorDebounce\", \"sensorDisabled\", \"resizeSensor\"], [\"scrollViewport\", \"\", \"hideNativeScrollbar\", \"\"], [4, \"ngIf\"], [\"scrollbarX\", \"\"], [\"scrollbarY\", \"\"]],\n    template: function NgScrollbar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵlistener(\"resizeSensor\", function NgScrollbar_Template_div_resizeSensor_1_listener() {\n          return ctx.update();\n        });\n        i0.ɵɵelementStart(2, \"div\", 2)(3, \"div\");\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵtemplate(5, NgScrollbar_ng_container_5_Template, 3, 2, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngAttr\", ctx.state);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"sensorDebounce\", ctx.sensorDebounce)(\"sensorDisabled\", ctx.sensorDisabled);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", !ctx.disabled);\n      }\n    },\n    directives: [ScrollbarX, ScrollbarY, NgAttr, ResizeSensor, ScrollViewport, HideNativeScrollbar, i9.NgIf],\n    styles: [\".ng-scrollbar-measure{scrollbar-width:none;-ms-overflow-style:none}  .ng-scrollbar-measure::-webkit-scrollbar{display:none}[_nghost-%COMP%]{--scrollbar-border-radius: 7px;--scrollbar-padding: 4px;--scrollbar-track-color: transparent;--scrollbar-thumb-color: rgba(0, 0, 0, .2);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-size: 5px;--scrollbar-hover-size: var(--scrollbar-size);--scrollbar-overscroll-behavior: initial;--scrollbar-transition-duration: .4s;--scrollbar-transition-delay: .8s;--scrollbar-thumb-transition: height ease-out .15s, width ease-out .15s;--scrollbar-track-transition: height ease-out .15s, width ease-out .15s;display:block;position:relative;height:100%;max-height:100%;max-width:100%;box-sizing:content-box!important}[_nghost-%COMP%] > .ng-scrollbar-wrapper[_ngcontent-%COMP%]{--scrollbar-total-size: calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size: var(--scrollbar-size);--horizontal-scrollbar-size: var(--scrollbar-size);--vertical-scrollbar-total-size: calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size: calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalHovered=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalDragging=true][_ngcontent-%COMP%]{--vertical-scrollbar-size: var(--scrollbar-hover-size);--vertical-scrollbar-total-size: calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalHovered=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalDragging=true][_ngcontent-%COMP%]{--horizontal-scrollbar-size: var(--scrollbar-hover-size);--horizontal-scrollbar-total-size: calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:0;right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:var(--scrollbar-total-size);right:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:var(--scrollbar-total-size);right:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:0;right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{top:0;bottom:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{top:var(--scrollbar-total-size);bottom:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{scrollbar-width:none;-ms-overflow-style:none}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]::-webkit-scrollbar, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport::-webkit-scrollbar{display:none}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-native-scrollbar-hider{bottom:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-native-scrollbar-hider{left:0;right:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-native-scrollbar-hider{right:0;left:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%] > .scrollbar-control[_ngcontent-%COMP%]{opacity:0;transition-property:opacity;transition-duration:var(--scrollbar-transition-duration);transition-delay:var(--scrollbar-transition-delay)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:hover > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:active > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:focus > .scrollbar-control[_ngcontent-%COMP%]{opacity:1;transition-duration:var(--scrollbar-transition-duration);transition-delay:0ms}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >   .ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{overflow:hidden}.ng-scroll-viewport[_ngcontent-%COMP%]{-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position;overscroll-behavior:var(--scrollbar-overscroll-behavior)}  .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scrollbar-wrapper[_ngcontent-%COMP%], .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], .ng-scroll-layer[_ngcontent-%COMP%],   .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}\", \".ng-scrollbar-wrapper[pointerEventsMethod=viewport]>.scrollbar-control{pointer-events:none}  .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>*>*>  .ng-scroll-viewport,   .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>*>*>  .ng-scroll-viewport,   .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>*>*>  .ng-scroll-viewport{-webkit-user-select:none;-moz-user-select:none;user-select:none}  .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:var(--scrollbar-track-transition)}  .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}  .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:var(--scrollbar-track-transition);cursor:default}  .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:var(--scrollbar-thumb-transition)}\"],\n    changeDetection: 0\n  });\n  return NgScrollbar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgScrollbarModule = /*#__PURE__*/(() => {\n  class NgScrollbarModule {\n    static withConfig(options) {\n      return {\n        ngModule: NgScrollbarModule,\n        providers: [{\n          provide: NG_SCROLLBAR_OPTIONS,\n          useValue: options\n        }]\n      };\n    }\n\n  }\n\n  NgScrollbarModule.ɵfac = function NgScrollbarModule_Factory(t) {\n    return new (t || NgScrollbarModule)();\n  };\n\n  NgScrollbarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgScrollbarModule\n  });\n  NgScrollbarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, BidiModule, PortalModule, PlatformModule, SmoothScrollModule]]\n  });\n  return NgScrollbarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of ngx-scrollbar\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { NG_SCROLLBAR_OPTIONS, NgScrollbar, NgScrollbarModule, ScrollViewport, ScrollbarManager }; //# sourceMappingURL=ngx-scrollbar.mjs.map","map":null,"metadata":{},"sourceType":"module"}